#!/usr/bin/python3

import math
from itertools import combinations
import numpy as np
import sys
import os

def ED(filename):
    xyRegex = r"(\S+)\s+(\S+)"
    XY = np.fromregex(filename,xyRegex,[('X',np.dtype(float)),('Y',np.dtype(float))])
    X_vals = XY['X'].tolist()
    Y_vals = XY['Y'].tolist()
    return X_vals,Y_vals

def Derive(X,Y,m,n):
    K = math.floor(n/2)
    N = len(X)-1

    def D(u,v):
        return (Y[v] - Y[u])/(X[v] - X[u])

    def calculateDerivative():
        Coefficients = []
        for i,x in enumerate(X):
            if i <= K-1:
                factor = 0
            elif i >= K and i <= N-K-1:
                factor = i-K
            else:
                factor = N-n
            Coefficients.append([])
            for j in range(n+1):
                if j != i-factor:

                    delta = [X[k+factor]-x for k in range(n+1) if k != i-factor and k != j]
                    deltaLength = len(delta)

                    combos = list(combinations(range(deltaLength),int(deltaLength-m+1)))
                    products = [1 for combo in combos]                             
                    for comb in combos:                                        
                        for val in comb:                                   
                            products[combos.index(comb)] *= delta[val]
                    a = sum(products)                                          
                    
                    productOfSpacings = np.product([X[k+factor]-X[j+factor] for k in range(n+1) if k != i-factor and k != j])

                    Coefficients[i].append([j+factor,((-1)**(m-1)*math.factorial(m)*a)/productOfSpacings])

        #print(sum([sum([b for a,b in i]) for i in Coefficients])) # should be 1 for m=1 and 0 for m>1
        return [sum([c*D(Coefficients.index(i),j) for j,c in i]) for i in Coefficients]
    return calculateDerivative()

def Plot(X,Y,dY=[],Title=''):
    import matplotlib.pyplot as plt
    import seaborn
    plt.figure(1)
    if dY == []:
        plt.plot(X,Y,'o')
    else:
        plt.plot(X,Y,'o',label=r"$Original\ Data$")
        plt.plot(X,dY,'o',label=r"$m^{th}\ Derivative$")
        plt.legend(loc='best',fontsize=14)
    plt.xlabel(r'$X\ Axis$',fontsize=12)
    plt.ylabel(r'$Y\ Axis$',fontsize=12)
    plt.title(Title,fontsize=24)
    plt.show()

if __name__ == '__main__':
    rawDataPath = str(sys.argv[1])
    derivativeOrder = int(sys.argv[2])
    numPoints = int(sys.argv[3])
    if derivativeOrder < 0:
        raise SystemExit('Not a valid derivative order')
    if numPoints <= derivativeOrder:
        raise SystemExit('Not a valid number of points to use')
    if os.path.exists(rawDataPath):
        Xvals,Yvals = ED(rawDataPath)
    else:
        raise SystemExit('Not a valid path to data')
    dY = Derive(Xvals,Yvals,derivativeOrder,numPoints)
    try:
        with open('deriveData.dat','w') as F:
            F.write('\n'.join(['{x}\t{y}'.format(x=u,y=v) for u,v in zip(Xvals,dY)]))
        Plot(Xvals,Yvals,dY,Title=r'${}^{{th}}\ derivative\ using\ {}\ points$'.format(derivativeOrder,numPoints))
    except:
        pass
